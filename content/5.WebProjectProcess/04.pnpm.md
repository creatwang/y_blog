# pnpm 包管理工具

> pnpm: performant npm缩写 -> 高性能的 npm 

- **Vue在内**的微软、字节很多公司或者开源项目的包管理工具都切换到了pnpm；



## pnpm的优势



### 优势一：硬链接依赖包

> 当使用 npm 或 Yarn 时，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。



- 在pnpm中会将所有文件都**保存在硬盘上的统一的位置**
- pnpm 会对同一**依赖包**使用**相同的版本**，那么磁盘上**只有这个依赖包的一份文件**
- 同一依赖包需要**使用不同的版本**，则**仅有版本之间不同**<u>的文件会被存储起来；</u>

> 当安装软件包时， 其包含的所有文件都 <u>会硬链接到指定的位置</u>，有而不会占用 **额外的硬盘空间；**
> ✓ 这让你可以在项目之间方便地共享相同版本的依赖包；



#### 硬链接的概念

> 在计算机当中<u>真正保存文件</u>的地方是在**disk(磁盘空间)当中**，例**在windows的文件系统当中的文件名**实际上是和磁盘空间中**真正的文件**进行了一个 **硬链接** ，以<u>直接执行或查看该文件。也可以手动的创建一个硬链接</u>



- 硬链接（英语：hard<硬> link）是电脑<u>文件系统中</u>的**多个文件**<u>平等地共享同一个</u>**文件存储单元(存储的一个表示)**；
  
- <u>删除一个文件名字后</u>，还可以用**其它名字(标识)继续访问该文件**；
  
- 创建硬链接

  ~~~shell
  //给aaa.js创建硬链接 这里的 /H 也可是使用小写的 /h 
  windows命令:    mklink /H aaa_hard.js aaa.js
  macos  命令:    ln foo.js foo_hard.js
  ~~~

- 创建了硬链接之后，两个相同链接的文件会相互影响，**两个链接都会操作磁盘中的文件**
- **注意：pnpm 创建硬链接是不能跨磁盘的**



#### 软链接的概念

> 符号链接也叫软连接，软连接文件当中保存的一个硬连接的文件路径 (绝对/相对路径) ，依赖于硬链接的标识。文件被删除软连接也会被删除。



- 符号链接（软链接soft link、Symbolic link）：
  - 符号链接（软链接、Symbolic link）是一类特殊的文件；
  - <u>其包含有一条</u>**以绝对路径或者相对路径的形式 **<u>指向其它文件或者目录的引用</u>；
  - 就是一个**快捷方式**



- 创建软连接

  ~~~shell
  #给aaa.js创建软链接 注意：这里是反着来的 aaa.js在前面
  windows命令:   mklink aaa.js aaa_soft.js
  macos  命令:   ln -s foo.js foo_copy.js
  #为 xindex.js <<===>> index.js 创建的符号链接
  ~~~

- 同样当软连接改变的之后，和硬链接不同的是**软连接是通过硬链接来修改磁盘中的文件**

  > 软连接根据**存放的链接**来修改源文件



#### 总结

> 使用硬链接的好处就是，性能快如果多个项目中使用相同的包不用下载缓存，解压，直接创键一个硬件链接即可，节省磁盘空间
>
> 非扁平化的结构(软连接)，可以更加直观的查看依赖



### 优势二: 非扁平的 node_modules 目录

> 当使用 npm 或 Yarn Classic 安装依赖包时，所有软件包都将被提升到 `node_modules` 的 根目录下。命令都会放到 `.bin` 文件当中
>
> 会显得代码比较混乱

- 主要原因就是，当下载指定包得时候，`node_modules` 当中还会存在下载包的依赖，为了保证包依赖的复用，都会放在 `node_modules` 的根路径下，这样下载其他包的时候如果存在复用的依赖可以直接使用。

  > 其结果是，源码可以访问 本不属于当前项目所设定的依赖包；

  - 扁平化的目录解决复用的情况下，也产生了别的问题

  - 这样会导致，package.json 中的没有记录的依赖则可以直接使用。这样会不太好

    > 其实也没有什么大的问题



#### pnpm 非扁平化目录的处理流程



1. 将下载的包存放到当前磁盘指定的路径下

   > 可以使用 `pnpm store path` 查看包保存的路径

2. 创建一个硬链接到项目的 `node_modules` 文件夹当中的 `.pnpm`

   > `.pnpm` 里会存放你所下载的依赖

3. 同时又会在  `node_modules` 当中创建所下载依赖的软连接 --> 指向 .pnpm文件夹当中真实依赖包名文件下的 `node_modules` 文件夹

4. 依赖都会如此，这样的使用 require() 查找获取模块的时候就不会引用到 package.json中的不存在的模块了

- **以为什么会直接链接到node_modules文件中 而不是直接放到包名下**



#### pnpm的存储store

> 在pnpm7.0之前，统一的存储位置是 ~/.pnpm-score中的；
>
> 在pnpm7.0之后，统一的存储位置进行了更改：`<pnpm home directory>/store`

- 在 Linux 上，默认是 ~/.local/share/pnpm/store
- 在 Windows 上： %LOCALAPPDATA%/pnpm/store
- 在 macOS 上： ~/Library/pnpm/store

- 获取当前活跃的store目录

  ~~~shell
  pnpm store path
  ~~~

- (重要)prune（修剪）：从 `store` 中删除当前未被引用的包来释放store的空间

  > 虽然有硬链接的方式节省磁盘空间但是包会不断的更新总会有低版本以后都不在使用了这样的话会一直占用额内存空间，这个时候我们可以使用 `pnpm store prune` 来进行剪切，会在真实存放包的路径下将没有链接引用的包清楚来释放内存空间

  ~~~js
  pnpm store prune
  ~~~




## pnpm的安装和使用

[官网提供的安装方式](https://www.pnpm.cn/installation)；或者直接 `npm i -g pnpm`



### 常用命令

[常用命令](https://pnpm.io/zh/)；可以在官网查看命令

| npm命令              | pnpm名令                       | 描述                                                         |
| -------------------- | ------------------------------ | ------------------------------------------------------------ |
| npm install          | pnpm instal                    | 下载pageage.json中的依赖                                     |
| npm install `<pkg>`  | pnpm add/install `<pkg>`       | 下载依赖                                                     |
| npm uninstall`<pkg>` | pnpm remove`<pkg>`             | 卸载依赖                                                     |
| npm run`<cmd>`       | pnpm `<cmd>` 可以不使用run命令 | 运行`<script>` 脚本,<br>如果脚本名称是`pnpm`的命令关键字的话就要使用 `run`了 |







